// this file is generated by 'DiagnosticType.generator.kts'
package com.anatawa12.relocator.diagnostic

// TODO: remove companion object

/*
 * The class which represents a type of diagnostic.
 *
 * this class is not intended for extend by external class.
 */
abstract class BasicDiagnosticType internal constructor(
    val id: String,
    val kind: DiagnosticKind,
    protected val render: Any?,
) {
    internal abstract fun render(values: Array<Any?>): String
}

class DiagnosticType0 private constructor(
    name: String,
    kind: DiagnosticKind,
    message: String,
): BasicDiagnosticType(name, kind, message) {
    @JvmName("create")
    operator fun invoke(location: Location) = Diagnostic(this, location, arrayOf())
    override fun render(values: Array<Any?>): String = render as String

    companion object {
        // the constructor wrapper/bridge to protect from calling this method from java
        @JvmStatic @JvmName("new") internal fun new(
            name: String,
            kind: DiagnosticKind,
            message: String,
        ) = DiagnosticType0(name, kind, message)
    }
}

// begin loop generated code
class DiagnosticType1<T0> private constructor(
    name: String,
    kind: DiagnosticKind,
    message: MessageBuilder1<T0>,
): BasicDiagnosticType(name, kind, message) {
    @JvmName("create")
    operator fun invoke(
        value0: T0,
        location: Location,
    ) = Diagnostic(this, location, arrayOf(
        value0,
    ))

    @Suppress("UNCHECKED_CAST")
    override fun render(values: Array<Any?>): String = (render as MessageBuilder1<T0>).build(
        values[0] as T0,
    )

    companion object {
        // the constructor wrapper/bridge to protect from calling this method from java
        @JvmStatic @JvmName("new") internal fun <T0> new(
            name: String,
            kind: DiagnosticKind,
            message: MessageBuilder1<T0>,
        ) = DiagnosticType1(name, kind, message)
    }
}

class DiagnosticType2<T0, T1> private constructor(
    name: String,
    kind: DiagnosticKind,
    message: MessageBuilder2<T0, T1>,
): BasicDiagnosticType(name, kind, message) {
    @JvmName("create")
    operator fun invoke(
        value0: T0,
        value1: T1,
        location: Location,
    ) = Diagnostic(this, location, arrayOf(
        value0,
        value1,
    ))

    @Suppress("UNCHECKED_CAST")
    override fun render(values: Array<Any?>): String = (render as MessageBuilder2<T0, T1>).build(
        values[0] as T0,
        values[1] as T1,
    )

    companion object {
        // the constructor wrapper/bridge to protect from calling this method from java
        @JvmStatic @JvmName("new") internal fun <T0, T1> new(
            name: String,
            kind: DiagnosticKind,
            message: MessageBuilder2<T0, T1>,
        ) = DiagnosticType2(name, kind, message)
    }
}

class DiagnosticType3<T0, T1, T2> private constructor(
    name: String,
    kind: DiagnosticKind,
    message: MessageBuilder3<T0, T1, T2>,
): BasicDiagnosticType(name, kind, message) {
    @JvmName("create")
    operator fun invoke(
        value0: T0,
        value1: T1,
        value2: T2,
        location: Location,
    ) = Diagnostic(this, location, arrayOf(
        value0,
        value1,
        value2,
    ))

    @Suppress("UNCHECKED_CAST")
    override fun render(values: Array<Any?>): String = (render as MessageBuilder3<T0, T1, T2>).build(
        values[0] as T0,
        values[1] as T1,
        values[2] as T2,
    )

    companion object {
        // the constructor wrapper/bridge to protect from calling this method from java
        @JvmStatic @JvmName("new") internal fun <T0, T1, T2> new(
            name: String,
            kind: DiagnosticKind,
            message: MessageBuilder3<T0, T1, T2>,
        ) = DiagnosticType3(name, kind, message)
    }
}

class DiagnosticType4<T0, T1, T2, T3> private constructor(
    name: String,
    kind: DiagnosticKind,
    message: MessageBuilder4<T0, T1, T2, T3>,
): BasicDiagnosticType(name, kind, message) {
    @JvmName("create")
    operator fun invoke(
        value0: T0,
        value1: T1,
        value2: T2,
        value3: T3,
        location: Location,
    ) = Diagnostic(this, location, arrayOf(
        value0,
        value1,
        value2,
        value3,
    ))

    @Suppress("UNCHECKED_CAST")
    override fun render(values: Array<Any?>): String = (render as MessageBuilder4<T0, T1, T2, T3>).build(
        values[0] as T0,
        values[1] as T1,
        values[2] as T2,
        values[3] as T3,
    )

    companion object {
        // the constructor wrapper/bridge to protect from calling this method from java
        @JvmStatic @JvmName("new") internal fun <T0, T1, T2, T3> new(
            name: String,
            kind: DiagnosticKind,
            message: MessageBuilder4<T0, T1, T2, T3>,
        ) = DiagnosticType4(name, kind, message)
    }
}

// end loop generated code

